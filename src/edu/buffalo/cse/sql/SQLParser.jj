options{  IGNORE_CASE = true;}PARSER_BEGIN(SQLParser)package edu.buffalo.cse.sql;import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import java.util.List;import java.io.File;import java.io.FileReader;import java.io.IOException;import edu.buffalo.cse.sql.Schema;import edu.buffalo.cse.sql.Schema.Column;import edu.buffalo.cse.sql.data.Datum;import edu.buffalo.cse.sql.data.Datum.CastError;import edu.buffalo.cse.sql.plan.AggregateNode;import edu.buffalo.cse.sql.plan.AggregateNode.AggColumn;import edu.buffalo.cse.sql.plan.ExprTree;import edu.buffalo.cse.sql.plan.JoinNode;import edu.buffalo.cse.sql.plan.NullSourceNode;import edu.buffalo.cse.sql.plan.PlanNode;import edu.buffalo.cse.sql.plan.PlanNode.Binary;import edu.buffalo.cse.sql.plan.PlanNode.Unary;import edu.buffalo.cse.sql.plan.ProjectionNode;import edu.buffalo.cse.sql.plan.ScanNode;import edu.buffalo.cse.sql.plan.SelectionNode;import edu.buffalo.cse.sql.plan.UnionNode;public class SQLParser{  List < PlanNode > initParser(Map < String, Schema.TableFromFile > tables) throws ParseException, TokenMgrError  {    initTables(tables);    return initPlannode(tables);  }}PARSER_END(SQLParser)// ----------------------------------------------------------------------------
// TOKENS
// ----------------------------------------------------------------------------
SKIP :{  " "| "\n"| "\r"| "\t"| "\r\n"}TOKEN [ IGNORE_CASE ] : // KEYWORDS
{  < SELECT : "SELECT" >| < CREATE_TABLE : "CREATE TABLE" >| < FROM : "FROM" >| < JOIN : "JOIN" >| < WHERE : "WHERE" >| < ON : "ON" >| < GROUP : "GROUP" >| < BY : "BY" >| < UNION : "UNION" >| < AND : "AND" >| < AS : "AS" >| < ASC : "ASC" >| < DESC : "DESC" >| < OR : "OR" >| < NOT : "NOT" >| < TRUE : "TRUE" >| < FALSE : "FALSE" >| < FILEPATH : ("FROM FILE") >| < STRING_LITERAL : ([ "A"-"Z", "a"-"z" ])+ >| < STRING_SLASH : < STRING_LITERAL > ([ "\\", "\'" ])* >| < STRING_QUOTE : < STRING_LITERAL > ("\'")* >| < FILE_NAME : < STRING_LITERAL > (< DIVIDE > < STRING_LITERAL >)+ < DOT > < STRING_LITERAL >>}TOKEN [ IGNORE_CASE ] : // DATA TYPES
{  < INTEGER : "int" >| < DATE : "date" >| < FLOAT : "float" >| < STRING : "string" >| < BOOLEAN : "boolean" >| < DOUBLE : "double" >}TOKEN : // LITERALS
{  < NUMBER : ([ "0"-"9" ])+ >| < NEGATIVE : (< MINUS >)? < NUMBER >>| < EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < FLOATING_POINT_LITERAL :    < NUMBER > < DOT > < NUMBER > (< EXPONENT >)?  | ([ "+", "-" ])? < NUMBER > < DOT > < NUMBER > (< EXPONENT >)?  | < DOT > < NUMBER > (< EXPONENT >)?  | ([ "+", "-" ])? < NUMBER > < DOT > < EXPONENT >  | < NUMBER > < EXPONENT >  | < NUMBER > < DOT > < NUMBER > < EXPONENT >  | < NUMBER > (< EXPONENT >)? >}TOKEN : // SEPARATORS AND OPERATORS
{  < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >| < LESS : "<" >| < LESSEQUAL : "<=" >| < GREATER : ">" >| < GREATEREQUAL : ">=" >| < EQUAL : "=" >| < NOTEQUAL : "!=" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < PLUS : "+" >| < MINUS : "-" >| < QUOTE : "'" >| < OPEN : ("(") >| < CLOSE : (")") >}SPECIAL_TOKEN :{  < COMMENT : ("USING CSV")+ >}void initTables(Map < String, Schema.TableFromFile > tables) :{  Token T, path, open, close;  Schema.TableFromFile table = null;  LinkedHashMap < String, String > columnMap = null;}{  (    < CREATE_TABLE > T = < STRING_LITERAL > < OPEN >    {      columnMap = addColumns();    }    < CLOSE > < FILEPATH > < QUOTE > path = < FILE_NAME > < QUOTE > < SEMICOLON >    {      table = new Schema.TableFromFile(new File(path.image));      for (Map.Entry < String, String > iterator : columnMap.entrySet())      {        if (iterator.getValue().equals("int"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.INT));        }        else if (iterator.getValue().equals("float"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.FLOAT));        }        else if (iterator.getValue().equals("bool"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.BOOL));        }        else if (iterator.getValue().equals("string"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.STRING));        }      }      tables.put(T.image, table);    }  )*}LinkedHashMap < String, String > addColumns() :{  Token TName;  Token TType;  LinkedHashMap < String, String > var = new LinkedHashMap < String, String > ();}{  (    TName = < STRING_LITERAL > TType = < STRING_LITERAL > (< COMMA >)?    {      var.put(TName.image, TType.image);    }  )*  {    return var;  }}List < PlanNode > initPlannode(Map < String, Schema.TableFromFile > tables) :{  Token table = null, var = null, open = null, close = null, exp = null;  Token var2 = null, col = null, col2 = null, exp2 = null, union = null, as = null;  JoinNode lhs_join = null, rhs_join = null, jroot = null;  ExprTree lhs = null, rhs = null, root = null;  List < PlanNode > q = new ArrayList < PlanNode > ();  int exec = 0, un = 0, flt = 0, unode = 0;  ScanNode lhs_scan = null, rhs_scan = null;  PlanNode.Unary query_0 = null;  UnionNode uquery = null, temp = null;  NullSourceNode nullchild = new NullSourceNode(1);  Token ans = null;  Boolean flagExpression = false;  ExprTree.OpCode rootOp = null;  Token t = null;}{  (    < SELECT >    (      (        col = < NEGATIVE >        {          nullchild = new NullSourceNode(1);          flt = 1;        }      | col = < FLOATING_POINT_LITERAL >        {          nullchild = new NullSourceNode(1);          flt = 2;        }      | lhs = exprTerm()        {          if (lhs != null) flagExpression = true;        }      | lhs = selectExpr()        {          if (lhs != null) flagExpression = true;        }      | table = < STRING_LITERAL >      )      (       (          < DOT >       | open = < OPEN >      | as = < AS >)        (          var = < STRING_LITERAL >        | var = < MULTIPLY >        )        (          (            exp = < PLUS >          | exp = < MULTIPLY >          | exp = < DIVIDE >          | exp = < MINUS >          )          var2 = < STRING_LITERAL >        )*        (close = < CLOSE >)?      )?      {        if (flagExpression == true)        {          if (as == null)          {            query_0 = new ProjectionNode();            ((ProjectionNode) query_0).addColumn(new ProjectionNode.Column("EXPR", lhs));          }          else          {            if (un == 0)            {              query_0 = new ProjectionNode();              un = 1;            }            ((ProjectionNode) query_0).addColumn(new ProjectionNode.Column(var.image, lhs));          }        }        else if (open == null)        {          if (un == 0)          {            query_0 = new ProjectionNode();            un = 1;          }          if (col != null)          {            if (flt == 1) ((ProjectionNode) query_0).addColumn(new ProjectionNode.Column("EXPR", new ExprTree.ConstLeaf(Integer.parseInt(col.image))));            else if (flt == 2) ((ProjectionNode) query_0).addColumn(new ProjectionNode.Column("EXPR", new ExprTree.ConstLeaf(Float.parseFloat(col.image))));          }          else if (var != null && open == null) ((ProjectionNode) query_0).addColumn(new ProjectionNode.Column(var.image, new ExprTree.VarLeaf(table.image, var.image)));          else if (var == null && open == null)          {            ((ProjectionNode) query_0).addColumn(new ProjectionNode.Column(table.image, new ExprTree.VarLeaf(table.image)));            exec = - 1;          }        }        else        {          if (un == 0)          {            query_0 = new AggregateNode();            un = 2;          }          if (exp == null)          {            if (table.image.equals("SUM")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Sum", new ExprTree.VarLeaf(null, var.image), AggregateNode.AType.SUM));            else if (table.image.equals("AVG")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Avg", new ExprTree.VarLeaf(null, var.image), AggregateNode.AType.AVG));            else if (table.image.equals("MIN")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Min", new ExprTree.VarLeaf(null, var.image), AggregateNode.AType.MIN));            else if (table.image.equals("MAX")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Max", new ExprTree.VarLeaf(null, var.image), AggregateNode.AType.MAX));            else if (table.image.equals("COUNT")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Count", new ExprTree.ConstLeaf(1), AggregateNode.AType.COUNT));          }          else          {            if (exp.image.equals("+"))            {              if (table.image.equals("SUM")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Sum", new ExprTree(ExprTree.OpCode.ADD, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.SUM));              else if (table.image.equals("AVG")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Avg", new ExprTree(ExprTree.OpCode.ADD, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.AVG));            }            else if (exp.image.equals("*"))            {              if (table.image.equals("SUM")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Sum", new ExprTree(ExprTree.OpCode.MULT, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.SUM));              else if (table.image.equals("AVG")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Avg", new ExprTree(ExprTree.OpCode.MULT, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.AVG));            }            else if (exp.image.equals("-"))            {              if (table.image.equals("SUM")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Sum", new ExprTree(ExprTree.OpCode.SUB, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.SUM));              else if (table.image.equals("AVG")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Avg", new ExprTree(ExprTree.OpCode.SUB, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.AVG));            }            else if (exp.image.equals("*"))            {              if (table.image.equals("SUM")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Sum", new ExprTree(ExprTree.OpCode.DIV, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.SUM));              else if (table.image.equals("AVG")) ((AggregateNode) query_0).addAggregate(new AggregateNode.AggColumn("Avg", new ExprTree(ExprTree.OpCode.DIV, new ExprTree.VarLeaf(null, var.image), new ExprTree.VarLeaf(null, var2.image)), AggregateNode.AType.AVG));            }          }        }      }      (< AS > < STRING_LITERAL >)? (< COMMA >)?    )+    (      < FROM >      (        (          table = < STRING_LITERAL >          (            < COMMA >          | < JOIN >          )?          {            for (Map.Entry < String, Schema.TableFromFile > iterator : tables.entrySet())            {              if (iterator.getKey().equals(table.image))              {                lhs_scan = new ScanNode(table.image, table.image, iterator.getValue());              }            }          }        )        (          table = < STRING_LITERAL >          (            < COMMA >          | < JOIN >          )?          {            for (Map.Entry < String, Schema.TableFromFile > iterator : tables.entrySet())            {              if (iterator.getKey().equals(table.image))              {                rhs_scan = new ScanNode(table.image, table.image, iterator.getValue());              }            }          }        )?        {          if (lhs_scan != null && rhs_scan != null)          {            if (lhs_join == null)            {              lhs_join = new JoinNode();              lhs_join.setLHS(lhs_scan);              lhs_join.setRHS(rhs_scan);              lhs_scan = null;              rhs_scan = null;            }            else if (rhs_join == null)            {              rhs_join = new JoinNode();              rhs_join.setLHS(lhs_scan);              rhs_join.setRHS(rhs_scan);              jroot = new JoinNode();              jroot.setLHS(lhs_join);              jroot.setRHS(rhs_join);              lhs_join = null;              rhs_join = null;              lhs_scan = null;              rhs_scan = null;            }          }          else if (lhs_scan != null && rhs_scan == null)          {            if (jroot == null && lhs_join != null)            {              jroot = new JoinNode();              jroot.setLHS(lhs_join);              jroot.setRHS(lhs_scan);              lhs_join = null;              lhs_scan = null;            }            else if (jroot != null && lhs_join == null)            {              lhs_join = jroot;              jroot.setLHS(lhs_join);              jroot.setRHS(lhs_scan);              lhs_join = null;              lhs_scan = null;            }          }        }      )+      {        if (lhs_join != null)        {          jroot = lhs_join;          lhs_join = null;        }        if (lhs_scan != null) exec = - 1;      }      (        < WHERE >        {          if (un == 1) selectExpression(jroot, ((ProjectionNode) query_0));          else if (un == 2) selectExpression(jroot, ((AggregateNode) query_0));          exec = 1;        }      )?      (        < ON >        {          if (un == 1) selectExpression(jroot, ((ProjectionNode) query_0));          else if (un == 2) selectExpression(jroot, ((AggregateNode) query_0));          exec = 1;        }      )?    )?    (      < SEMICOLON >    | union = < UNION >      {        if (union != null) unode++;      }    )    {      if (flagExpression || (col != null))      {        query_0.setChild(nullchild);      }      else if (exec == 0) query_0.setChild(jroot);      else if (exec == - 1) query_0.setChild(lhs_scan);      exec = 0;      un = 0;      if (unode == 0) q.add(query_0);      if (union != null)      {        if (unode == 1)        {          uquery = new UnionNode();          uquery.setLHS(query_0);        }        else if (unode == 2)        {          uquery.setRHS(query_0);          temp = new UnionNode();          temp.setLHS(uquery.getLHS());          temp.setRHS(uquery.getRHS());        }      }      else if (union == null && unode > 0)      {        if (unode == 1)        {          uquery.setRHS(query_0);        }        if (unode == 2)        {          uquery.setLHS(temp);          uquery.setRHS(query_0);        }        q.add(uquery);      }      union = null;    }  )+  < EOF >  {    return q;  }}void selectExpression(JoinNode jroot, PlanNode.Unary query_0) :{  SelectionNode expression = null;  ExprTree.OpCode rootOp = null;  ExprTree lhs = null;  ExprTree rhs = null;  ExprTree root = null, lroot = null, rroot = null;  Token open, close;  int flag = 0;}{  (    (      open = < OPEN >      {        if (open.image != null) flag++;      }    )?    lhs = queryTerm()    (      close = < CLOSE >      {        if (close.image != null) flag--;      }    )?    (      < AND >      {        if (expression == null)        {          if (flag == 0) rootOp = ExprTree.OpCode.AND;        }      }      (        open = < OPEN >        {          if (open.image != null) flag++;        }      )+      rhs = queryTerm()      (        close = < CLOSE >        {          if (close.image != null) flag--;        }      )+      {        if (lroot == null && flag == 0)        {          lroot = new ExprTree(ExprTree.OpCode.AND, lhs, rhs);          lhs = null;          rhs = null;        }        else if (lroot == null && flag > 0)        {          lroot = lhs;          lhs = rhs;          rhs = null;        }        else if (lroot != null && flag > 0)        {          rroot = rhs;          rhs = null;        }        else if (lroot != null && rroot == null && flag == 0)        {          rroot = new ExprTree(ExprTree.OpCode.AND, lhs, rhs);          lhs = null;          rhs = null;        }        if (lroot != null && rroot != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rroot);          lroot = null;          rroot = null;        }        else if (lroot != null && rroot == null && lhs != null && rhs == null && flag == 0)        {          root = new ExprTree(rootOp, lroot, lhs);          lroot = null;          lhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rhs);          lroot = null;          rhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs == null && flag == 0)        {          root = lroot;          lroot = null;        }        else if (lhs != null && lroot == null && rroot == null && rhs == null && flag == 0)        {          root = lhs;          lhs = null;        }      }    | < OR >      {        if (expression == null)        {          if (flag == 0) rootOp = ExprTree.OpCode.OR;        }      }      (        open = < OPEN >        {          if (open.image != null) flag++;        }      )+      rhs = queryTerm()      (        close = < CLOSE >        {          if (close.image != null) flag--;        }      )+      {        if (lroot == null && flag == 0)        {          lroot = new ExprTree(ExprTree.OpCode.OR, lhs, rhs);          lhs = null;          rhs = null;        }        else if (lroot == null && flag > 0)        {          lroot = lhs;          lhs = rhs;          rhs = null;        }        else if (lroot != null && flag > 0)        {          rroot = rhs;          rhs = null;        }        else if (lroot != null && rroot == null && lhs != null && rhs != null && flag == 0)        {          rroot = new ExprTree(ExprTree.OpCode.OR, lhs, rhs);          lhs = null;          rhs = null;        }        if (lroot != null && rroot != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rroot);          lroot = null;          rroot = null;        }        else if (lroot != null && rroot == null && lhs != null && rhs == null && flag == 0)        {          root = new ExprTree(rootOp, lroot, lhs);          lroot = null;          lhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rhs);          lroot = null;          rhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs == null && flag == 0)        {          root = lroot;          lroot = null;        }        else if (lhs != null && lroot == null && rroot == null && rhs == null && flag == 0)        {          root = lhs;          lhs = null;        }      }    )*  )*  {    if (lhs != null && lroot == null && rroot == null && rhs == null && flag == 0)    {      root = lhs;      lhs = null;    }    if (expression == null)    {      expression = new SelectionNode(root);      expression.setChild(jroot);      query_0.setChild(expression);    }  }}ExprTree selectExpr() :{  Token open = null, ans = null;  ExprTree lhs = null, rhs = null, root = null;  Boolean flagExpression = false;  int flag = 0;  ExprTree.OpCode rootOp = null;  Token close = null, temp = null, a = null;  ExprTree temporary = null;}{  < OPEN >  (    (< OPEN >)  | temporary = exprTerm()    {      if (lhs == null)      {        lhs = temporary;      }      else      {        rhs = temporary;        if (rootOp != null)        {          lhs = new ExprTree(rootOp, lhs, rhs);        }      }    }    (close = < CLOSE >)?    (      temp = < MULTIPLY >      {        rootOp = ExprTree.OpCode.MULT;      }    | < DIVIDE >      {        rootOp = ExprTree.OpCode.DIV;      }    | < PLUS >      {        rootOp = ExprTree.OpCode.ADD;      }    | < MINUS >      {        rootOp = ExprTree.OpCode.SUB;      }    )?  )+  {    return lhs;  }}ExprTree exprTerm() :{  Token lc = null, rc = null, exp = null, notCheck = null, checkQuote = null;  ExprTree.OpCode rootOp = null;  ExprTree rhs = null;  ExprTree rootExpr = null;}{  (notCheck = < NOT >)?  (    lc = < FLOATING_POINT_LITERAL >  | lc = < NUMBER >  | lc = < TRUE >  | lc = < FALSE >  | lc = < QUOTE >  )  (    exp = < MULTIPLY >  | exp = < DIVIDE >  | exp = < PLUS >  | exp = < MINUS >  | exp = < AND >  | exp = < OR >  | exp = < STRING_LITERAL >  | exp = < STRING_SLASH >  )?  {    if (exp == null)    {      if (notCheck != null) return new ExprTree(ExprTree.OpCode.NOT, new ExprTree.ConstLeaf(Boolean.parseBoolean(lc.image)));      else if (lc.image.toUpperCase().equals("TRUE") || lc.image.toUpperCase().equals("FALSE")) return new ExprTree.ConstLeaf(Boolean.parseBoolean(lc.image));      else return new ExprTree.ConstLeaf(Integer.parseInt(lc.image));    }  }  (    (      rc = < NUMBER >    | rc = < TRUE >    | rc = < FALSE >    | rc = < QUOTE >    )  )?  {    if (lc.image.equals("'"))    {      String t = exp.image;      if (t.contains("\\\\'"))      {        t = t.replace("\\\\'", "\\");      }      else if (t.contains("\\'"))      {        t = t.replace("\\'", "''");      }      else      {        t = t.replace("'", "");        if (t.contains("\\")) t = t.replace("\\", "'");        if (t.contains("\\'"))        {}        else        {          t = t.replace("'", "\\");        }      }      t = t.replace("'''", "'");      rootExpr = new ExprTree.ConstLeaf(t);    }    else if (exp.image.equals("+"))    {      rootExpr = new ExprTree(ExprTree.OpCode.ADD, new ExprTree.ConstLeaf(Integer.parseInt(lc.image)), new ExprTree.ConstLeaf(Integer.parseInt(rc.image)));    }    else if (exp.image.equals("-"))    {      rootExpr = new ExprTree(ExprTree.OpCode.SUB, new ExprTree.ConstLeaf(Integer.parseInt(lc.image)), new ExprTree.ConstLeaf(Integer.parseInt(rc.image)));    }    else if (exp.image.equals("*"))    {      rootExpr = new ExprTree(ExprTree.OpCode.MULT, new ExprTree.ConstLeaf(Integer.parseInt(lc.image)), new ExprTree.ConstLeaf(Integer.parseInt(rc.image)));    }    else if (exp.image.equals("/"))    {      rootExpr = new ExprTree(ExprTree.OpCode.DIV, new ExprTree.ConstLeaf(Integer.parseInt(lc.image)), new ExprTree.ConstLeaf(Integer.parseInt(rc.image)));    }    else if (exp.image.equals("AND"))    {      rootExpr = new ExprTree(ExprTree.OpCode.AND, new ExprTree.ConstLeaf(Boolean.parseBoolean(lc.image)), new ExprTree.ConstLeaf(Boolean.parseBoolean(rc.image)));    }    else if (exp.image.equals("OR"))    {      rootExpr = new ExprTree(ExprTree.OpCode.OR, new ExprTree.ConstLeaf(Boolean.parseBoolean(lc.image)), new ExprTree.ConstLeaf(Boolean.parseBoolean(rc.image)));    }    return rootExpr;  }}ExprTree queryTerm() :{  ExprTree rootCompareOp = null;  ExprTree.OpCode rootOpCode = null;  Token tname1;  Token cname1;  Token tname2;  Token cname2;  int flag = 0;}{  (    tname1 = < STRING_LITERAL > < DOT > cname1 = < STRING_LITERAL >    (      < LESS >      {        rootOpCode = ExprTree.OpCode.LT;      }    | < LESSEQUAL >      {        rootOpCode = ExprTree.OpCode.LTE;      }    | < GREATER >      {        rootOpCode = ExprTree.OpCode.GT;      }    | < EQUAL >      {        rootOpCode = ExprTree.OpCode.EQ;      }    | < NOTEQUAL >      {        rootOpCode = ExprTree.OpCode.NEQ;      }    | < GREATEREQUAL >      {        rootOpCode = ExprTree.OpCode.GTE;      }    )    tname2 = < STRING_LITERAL > < DOT > cname2 = < STRING_LITERAL >    {      rootCompareOp = new ExprTree(rootOpCode, new ExprTree.VarLeaf(tname1.image, cname1.image), new ExprTree.VarLeaf(tname2.image, cname2.image));    }  )  {    return rootCompareOp;  }}
options{  IGNORE_CASE = true;}PARSER_BEGIN(SQLParser)package edu.buffalo.cse.sql;import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import java.util.List;import java.io.File;import java.io.FileReader;import java.io.IOException;import edu.buffalo.cse.sql.Schema;import edu.buffalo.cse.sql.Schema.Column;import edu.buffalo.cse.sql.data.Datum;import edu.buffalo.cse.sql.data.Datum.CastError;import edu.buffalo.cse.sql.plan.AggregateNode;import edu.buffalo.cse.sql.plan.AggregateNode.AggColumn;import edu.buffalo.cse.sql.plan.ExprTree;import edu.buffalo.cse.sql.plan.JoinNode;import edu.buffalo.cse.sql.plan.PlanNode;import edu.buffalo.cse.sql.plan.PlanNode.Binary;import edu.buffalo.cse.sql.plan.PlanNode.Unary;import edu.buffalo.cse.sql.plan.ProjectionNode;import edu.buffalo.cse.sql.plan.ScanNode;import edu.buffalo.cse.sql.plan.SelectionNode;public class SQLParser{  List<PlanNode > initParser(Map < String, Schema.TableFromFile > tables) throws ParseException, TokenMgrError  {    initTables(tables);    return initPlannode(tables);  }}PARSER_END(SQLParser)// ----------------------------------------------------------------------------
// TOKENS
// ----------------------------------------------------------------------------
SKIP :{  " "| "\n"| "\r"| "\t"| "\r\n"}TOKEN [ IGNORE_CASE ] : // KEYWORDS
{  < SELECT : "SELECT" >| < CREATE_TABLE : "CREATE TABLE" >| < FROM : "FROM" >| < JOIN : "JOIN" >| < WHERE : "WHERE" >| < ON : "ON" >| < GROUP : "GROUP" >| < BY : "BY" >| < AND : "AND" >| < AS : "AS" >| < ASC : "ASC" >| < DESC : "DESC" >| < OR : "OR" >| < STRING_LITERAL : ([ "A"-"Z", "a"-"z" ])+ >| < FILEPATH : ("FROM FILE") >| < FILE_NAME : < STRING_LITERAL > (< DIVIDE > < STRING_LITERAL >)+ < DOT > < STRING_LITERAL >>}TOKEN [ IGNORE_CASE ] : // DATA TYPES
{  < INTEGER : "int" >| < DATE : "date" >| < FLOAT : "float" >| < STRING : "string" >| < BOOLEAN : "boolean" >| < DOUBLE : "double" >}TOKEN : // LITERALS
{  < FLOATING_POINT_LITERAL :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])+ (< EXPONENT >)?  | "." ([ "0"-"9" ])+ (< EXPONENT >)?  | ([ "0"-"9" ])+ < EXPONENT >  | ([ "0"-"9" ])+ (< EXPONENT >)? >| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >}TOKEN : // IDENTIFIERS
{  < #LETTER : [ "A"-"Z", "a"-"z" ] >| < #DIGIT : [ "0"-"9" ] >| < NUMBER : ([ "0"-"9" ])+ >}TOKEN : // SEPARATORS AND OPERATORS
{  < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >| < LESS : "<" >| < LESSEQUAL : "<=" >| < GREATER : ">" >| < GREATEREQUAL : ">=" >| < EQUAL : "=" >| < NOTEQUAL : "!=" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < PLUS : "+" >| < MINUS : "-" >| < QUOTE : "'" >| < OPEN : ("(") >| < CLOSE : (")") >}SPECIAL_TOKEN :{  < COMMENT : ("USING CSV")+ >}void initTables(Map < String, Schema.TableFromFile > tables) :{  Token T, path;  Schema.TableFromFile table = null;  LinkedHashMap < String, String > columnMap = null;}{  (    < CREATE_TABLE > T = < STRING_LITERAL > < OPEN >    {      columnMap = addColumns();    }    < CLOSE > < FILEPATH > < QUOTE > path = < FILE_NAME > < QUOTE > <SEMICOLON >    {      table = new Schema.TableFromFile(new File(path.image));      for (Map.Entry < String, String > iterator : columnMap.entrySet())      {        if (iterator.getValue().equals("int"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.INT));        }        else if (iterator.getValue().equals("float"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.FLOAT));        }        else if (iterator.getValue().equals("bool"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.BOOL));        }        else if (iterator.getValue().equals("string"))        {          table.add(new Schema.Column(T.image, iterator.getKey(), Schema.Type.STRING));        }      }      tables.put(T.image, table);    }  )*}LinkedHashMap < String, String > addColumns() :{  Token TName;  Token TType;  LinkedHashMap < String, String > var = new LinkedHashMap < String, String > ();}{  (    TName = < STRING_LITERAL > TType = < STRING_LITERAL > (< COMMA >)?    {      var.put(TName.image, TType.image);    }  )*  {    return var;  }}List<PlanNode > initPlannode(Map < String, Schema.TableFromFile > tables) :{  Token table, var=null;  JoinNode lhs_join = null, rhs_join = null, jroot = null;  ExprTree lhs = null, rhs = null, root = null;  List<PlanNode > q = new ArrayList<PlanNode >();  int exec = 0;  ScanNode lhs_scan = null, rhs_scan = null;}{  (    < SELECT >    {      ProjectionNode query_0 = new ProjectionNode();    }    (       table = < STRING_LITERAL > (< DOT > var = < STRING_LITERAL >)?      {        if(var!=null)        	query_0.addColumn(new ProjectionNode.Column(var.image, new ExprTree.VarLeaf(table.image, var.image)));        else        {        	query_0.addColumn(new ProjectionNode.Column(table.image, new ExprTree.VarLeaf(table.image)));        	exec = -1;       }      }      (< COMMA >)?    )+    (      < FROM >      (        (          table = < STRING_LITERAL >          (            < COMMA >          | < JOIN >          )?          {            for (Map.Entry < String, Schema.TableFromFile > iterator : tables.entrySet())            {              if (iterator.getKey().equals(table.image))              {                lhs_scan = new ScanNode(table.image, table.image, iterator.getValue());              }            }          }        )        (          table = < STRING_LITERAL >          (            < COMMA >          | < JOIN >          )?          {            for (Map.Entry < String, Schema.TableFromFile > iterator : tables.entrySet())            {              if (iterator.getKey().equals(table.image))              {                rhs_scan = new ScanNode(table.image, table.image, iterator.getValue());              }            }          }        )?        {          if (lhs_scan != null && rhs_scan != null)          {            if (lhs_join == null)            {              lhs_join = new JoinNode();              lhs_join.setLHS(lhs_scan);              lhs_join.setRHS(rhs_scan);              lhs_scan = null;              rhs_scan = null;            }            else if (rhs_join == null)            {              rhs_join = new JoinNode();              rhs_join.setLHS(lhs_scan);              rhs_join.setRHS(rhs_scan);              jroot = new JoinNode();              jroot.setLHS(lhs_join);              jroot.setRHS(rhs_join);              lhs_join = null;              rhs_join = null;              lhs_scan = null;              rhs_scan = null;            }          }          else if (lhs_scan != null && rhs_scan == null)          {            if (jroot == null && lhs_join != null)            {              jroot = new JoinNode();              jroot.setLHS(lhs_join);              jroot.setRHS(lhs_scan);              lhs_join = null;              lhs_scan = null;            }            else if (jroot != null && lhs_join == null)            {              lhs_join = jroot;              jroot.setLHS(lhs_join);              jroot.setRHS(lhs_scan);              lhs_join = null;              lhs_scan = null;            }          }        }      )+      {        if (lhs_join != null)        {          jroot = lhs_join;          lhs_join = null;        }      }      (         < WHERE >      {        selectExpression(jroot, query_0);        exec = 1;      }      )?      (         < ON >      {        selectExpression(jroot, query_0);        exec = 1;      }      )?    )?    < SEMICOLON >    {      if(exec == 0)      	query_0.setChild(jroot);      else if(exec == -1)      	query_0.setChild(lhs_scan);      exec = 0;	      q.add(query_0);    }  )+  < EOF >  {    return q;  }}void selectExpression(JoinNode jroot, ProjectionNode query_0) :{  SelectionNode expression = null;  ExprTree.OpCode rootOp = null;  ExprTree lhs = null;  ExprTree rhs = null;  ExprTree root = null, lroot = null, rroot = null;  Token open, close;  int flag = 0;}{  (    (      open = < OPEN >      {        if (open.image != null) flag++;      }    )?    lhs = queryTerm()    (      close = < CLOSE >      {        if (close.image != null) flag--;      }    )?    (      < AND >      {        if (expression == null)        {          if (flag == 0) rootOp = ExprTree.OpCode.AND;        }      }      (        open = < OPEN >        {          if (open.image != null) flag++;        }      )+      rhs = queryTerm()      (        close = < CLOSE >        {          if (close.image != null) flag--;        }      )+      {        if (lroot == null && flag == 0)        {          lroot = new ExprTree(ExprTree.OpCode.AND, lhs, rhs);          lhs = null;          rhs = null;        }        else if (lroot == null && flag > 0)        {          lroot = lhs;          lhs = rhs;          rhs = null;        }        else if (lroot != null && flag > 0)        {          rroot = rhs;          rhs = null;        }        else if (lroot != null && rroot == null && flag == 0)        {          rroot = new ExprTree(ExprTree.OpCode.AND, lhs, rhs);          lhs = null;          rhs = null;        }        if (lroot != null && rroot != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rroot);          lroot = null;          rroot = null;        }        else if (lroot != null && rroot == null && lhs != null && rhs == null && flag == 0)        {          root = new ExprTree(rootOp, lroot, lhs);          lroot = null;          lhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rhs);          lroot = null;          rhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs == null && flag == 0)        {          root = lroot;          lroot = null;        }        else if (lhs != null && lroot == null && rroot == null && rhs == null && flag == 0)        {          root = lhs;          lhs = null;        }      }    | < OR >      {        if (expression == null)        {          if (flag == 0) rootOp = ExprTree.OpCode.OR;        }      }      (        open = < OPEN >        {          if (open.image != null) flag++;        }      )+      rhs = queryTerm()      (        close = < CLOSE >        {          if (close.image != null) flag--;        }      )+      {        if (lroot == null && flag == 0)        {          lroot = new ExprTree(ExprTree.OpCode.OR, lhs, rhs);          lhs = null;          rhs = null;        }        else if (lroot == null && flag > 0)        {          lroot = lhs;          lhs = rhs;          rhs = null;        }        else if (lroot != null && flag > 0)        {          rroot = rhs;          rhs = null;        }        else if (lroot != null && rroot == null && lhs != null && rhs != null && flag == 0)        {          rroot = new ExprTree(ExprTree.OpCode.OR, lhs, rhs);          lhs = null;          rhs = null;        }        if (lroot != null && rroot != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rroot);          lroot = null;          rroot = null;        }        else if (lroot != null && rroot == null && lhs != null && rhs == null && flag == 0)        {          root = new ExprTree(rootOp, lroot, lhs);          lroot = null;          lhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs != null && flag == 0)        {          root = new ExprTree(rootOp, lroot, rhs);          lroot = null;          rhs = null;        }        else if (lroot != null && rroot == null && lhs == null && rhs == null && flag == 0)        {          root = lroot;          lroot = null;        }        else if (lhs != null && lroot == null && rroot == null && rhs == null && flag == 0)        {          root = lhs;          lhs = null;        }      }    )*  )*  {    if (lhs != null && lroot == null && rroot == null && rhs == null && flag == 0)    {      root = lhs;      lhs = null;    }    if (expression == null)    {      expression = new SelectionNode(root);      expression.setChild(jroot);      query_0.setChild(expression);    }  }}ExprTree queryTerm() :{  ExprTree rootCompareOp = null;  ExprTree.OpCode rootOpCode = null;  Token tname1;  Token cname1;  Token tname2;  Token cname2;  int flag = 0;}{  (    tname1 = < STRING_LITERAL > < DOT > cname1 = < STRING_LITERAL >    (      < LESS >      {        rootOpCode = ExprTree.OpCode.LT;      }    | < LESSEQUAL >      {        rootOpCode = ExprTree.OpCode.LTE;      }    | < GREATER >      {        rootOpCode = ExprTree.OpCode.GT;      }    | < EQUAL >      {        rootOpCode = ExprTree.OpCode.EQ;      }    | < NOTEQUAL >      {        rootOpCode = ExprTree.OpCode.NEQ;      }    | < GREATEREQUAL >      {        rootOpCode = ExprTree.OpCode.GTE;      }    )    tname2 = < STRING_LITERAL > < DOT > cname2 = < STRING_LITERAL >    {      rootCompareOp = new ExprTree(rootOpCode, new ExprTree.VarLeaf(tname1.image, cname1.image), new ExprTree.VarLeaf(tname2.image, cname2.image));    }  )  {    return rootCompareOp;  }}